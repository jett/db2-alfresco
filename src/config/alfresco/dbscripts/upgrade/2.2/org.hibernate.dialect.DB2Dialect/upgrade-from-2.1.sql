--
-- Title:      Apply schema modifications to upgrade from 2.1.a 
-- Database:   DB2
-- Since:      V2.1.a Schema 81
-- Author:     
--
-- In order to streamline the upgrade, all modifications to large tables need to
-- be handled in as few steps as possible.  This usually involves as few ALTER TABLE
-- statements as possible.  The general approach is:
--   Create a table with the correct structure, including indexes and CONSTRAINTs
--   Copy pristine data into the new table
--   Drop the old table
--   Rename the new table
--
-- Please contact support@alfresco.com if you need assistance with the upgrade.
--

-- -------------------------------
-- Build Namespaces and QNames --
-- -------------------------------

CREATE TABLE ALF_NAMESPACE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    URI VARCHAR(400) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (URI) 
);

CREATE TABLE ALF_QNAME ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    NS_ID BIGINT NOT NULL, 
    LOCAL_NAME VARCHAR(800) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (NS_ID, LOCAL_NAME) 
);
create index fk_alf_qname_ns on ALF_QNAME (ns_id);
alter table alf_qname add constraint fk_alf_qname_ns foreign key (ns_id) references alf_namespace;

-- Create temporary table to hold static QNames
CREATE TABLE T_QNAMES ( 
    QNAME VARCHAR(1020) NOT NULL, 
    NAMESPACE VARCHAR(400), 
    LOCALNAME VARCHAR(800),  
    QNAME_ID BIGINT 
);
CREATE INDEX TIDX_TQN_QN ON T_QNAMES (QNAME);
CREATE INDEX TIDX_TQN_NS ON T_QNAMES (NAMESPACE);
CREATE INDEX TIDX_TQN_LN ON T_QNAMES (LOCALNAME);

-- Populate the table with all known static QNames
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_NODE S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM ALF_NODE_ASPECTS S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM ALF_NODE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_ASPECTS S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.NAME FROM AVM_ASPECTS_NEW S LEFT OUTER JOIN T_QNAMES T ON (S.NAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_NODE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_NODE_PROPERTIES_NEW S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.QNAME FROM AVM_STORE_PROPERTIES S LEFT OUTER JOIN T_QNAMES T ON (S.QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_NODE_ASSOC S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_CHILD_ASSOC S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );
INSERT INTO T_QNAMES (QNAME) ( SELECT DISTINCT S.TYPE_QNAME FROM ALF_PERMISSION S LEFT OUTER JOIN T_QNAMES T ON (S.TYPE_QNAME = T.QNAME) WHERE T.QNAME IS NULL );

-- Extract the namespace and localnames from the QNames
UPDATE T_QNAMES SET NAMESPACE = CONCAT ('FILLER-', SUBSTR(QNAME, 2, POSSTR(QNAME, '}') - 2));
UPDATE T_QNAMES SET LOCALNAME = SUBSTR(QNAME, POSSTR(QNAME, '}') + 1);

-- Move the Namespaces to their new home
INSERT INTO ALF_NAMESPACE (URI, VERSION) ( SELECT DISTINCT(X.NAMESPACE), 1 FROM ( SELECT T.NAMESPACE, N.URI FROM T_QNAMES T LEFT OUTER JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) ) X  WHERE  X.URI IS NULL );

-- Move the Localnames to their new home
INSERT INTO ALF_QNAME (NS_ID, LOCAL_NAME, VERSION) ( SELECT X.NS_ID, X.T_LOCALNAME, 1 FROM ( SELECT N.ID AS NS_ID, T.LOCALNAME AS T_LOCALNAME, Q.LOCAL_NAME AS Q_LOCALNAME  FROM T_QNAMES T JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) LEFT OUTER JOIN ALF_QNAME Q ON (Q.LOCAL_NAME = T.LOCALNAME) ) X WHERE Q_LOCALNAME IS NULL GROUP BY X.NS_ID, X.T_LOCALNAME );

-- Record the new qname IDs
UPDATE T_QNAMES T SET T.QNAME_ID = ( SELECT Q.ID FROM ALF_QNAME Q JOIN ALF_NAMESPACE NS ON (Q.NS_ID = NS.ID)  WHERE NS.URI = T.NAMESPACE AND Q.LOCAL_NAME = T.LOCALNAME );

-- Create temporary table for dynamic (child) QNames
CREATE TABLE T_QNAMES_DYN ( 
    QNAME VARCHAR(1020) NOT NULL, 
    NAMESPACE VARCHAR(400), 
    NAMESPACE_ID BIGINT, 
    LOCAL_NAME VARCHAR(1020)
);
CREATE INDEX TIDX_QND_QN ON T_QNAMES_DYN (QNAME);
CREATE INDEX TIDX_QND_NS ON T_QNAMES_DYN (NAMESPACE);

-- Populate the table with the child association paths
INSERT INTO T_QNAMES_DYN (QNAME) (  SELECT DISTINCT(QNAME) FROM ALF_CHILD_ASSOC );

-- Extract the Namespace
UPDATE T_QNAMES_DYN SET NAMESPACE = CONCAT ('FILLER-', SUBSTR(QNAME, 2, POSSTR(QNAME, '}') - 2));

-- Extract the Localname
UPDATE T_QNAMES_DYN SET LOCAL_NAME = SUBSTR(QNAME, POSSTR(QNAME, '}') + 1);

-- Move the namespaces to the their new home
INSERT INTO ALF_NAMESPACE (URI, VERSION)( SELECT DISTINCT(X.NAMESPACE), 1 FROM ( SELECT T.NAMESPACE, N.URI FROM T_QNAMES_DYN T LEFT OUTER JOIN ALF_NAMESPACE N ON (N.URI = T.NAMESPACE) ) X WHERE X.URI IS NULL );

-- Record the new namespace IDs
UPDATE T_QNAMES_DYN T SET T.NAMESPACE_ID = (SELECT NS.ID FROM ALF_NAMESPACE NS WHERE NS.URI = T.NAMESPACE);

-- This is a small table so we change it in place
ALTER TABLE ALF_PERMISSION ADD COLUMN TYPE_QNAME_ID BIGINT;
UPDATE ALF_PERMISSION AS P SET P.TYPE_QNAME_ID = ( SELECT Q.ID FROM ALF_QNAME AS Q JOIN ALF_NAMESPACE NS ON (Q.NS_ID = NS.ID) WHERE CONCAT(CONCAT('{', SUBSTR(NS.URI, 8)), CONCAT('}', Q.LOCAL_NAME)) = P.TYPE_QNAME);

--ASSIGN:ap_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_PERMISSION;

CREATE TABLE T_ALF_PERMISSION (ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${ap_max_id}), 
    VERSION BIGINT NOT NULL, 
    NAME VARCHAR(400) NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (ID)
);

INSERT INTO T_ALF_PERMISSION (ID, VERSION, NAME, TYPE_QNAME_ID) ( SELECT ID, VERSION, NAME, TYPE_QNAME_ID FROM ALF_PERMISSION );
DROP TABLE ALF_PERMISSION;
RENAME T_ALF_PERMISSION TO ALF_PERMISSION;
ALTER TABLE ALF_PERMISSION ADD CONSTRAINT ALF_PERM_UNIQUE UNIQUE (TYPE_QNAME_ID, NAME);
CREATE INDEX FK_ALF_PERM_TQN ON ALF_PERMISSION (TYPE_QNAME_ID);
ALTER TABLE ALF_PERMISSION ADD CONSTRAINT FK_ALF_PERM_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);
alter table alf_access_control_entry add constraint fk_alf_ace_perm foreign key (permission_id) references alf_permission;

-- -------------------
-- Build new Store --
-- -------------------
CREATE TABLE T_ALF_STORE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    PROTOCOL VARCHAR(200) NOT NULL, 
    IDENTIFIER VARCHAR(400) NOT NULL, 
    ROOT_NODE_ID BIGINT, 
    PRIMARY KEY (ID), 
    UNIQUE (PROTOCOL, IDENTIFIER) 
);

-- --------------------------
-- Populate the ADM nodes --
-- --------------------------
--ASSIGN:an_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_NODE;

CREATE TABLE T_ALF_NODE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${an_max_id}), 
    VERSION BIGINT NOT NULL, 
    STORE_ID BIGINT NOT NULL, 
    UUID VARCHAR(144) NOT NULL, 
    TRANSACTION_ID BIGINT NOT NULL, 
    NODE_DELETED SMALLINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    ACL_ID BIGINT, 
    AUDIT_CREATOR VARCHAR(1020), 
    AUDIT_CREATED VARCHAR(120), 
    AUDIT_MODIFIER VARCHAR(1020), 
    AUDIT_MODIFIED VARCHAR(120), 
    AUDIT_ACCESSED VARCHAR(120), 
    PRIMARY KEY (ID), 
    UNIQUE (STORE_ID, UUID) 
);
CREATE INDEX FK_ALF_NODE_ACL ON T_ALF_NODE (ACL_ID);
CREATE INDEX FK_ALF_NODE_STORE ON T_ALF_NODE (STORE_ID);
CREATE INDEX FK_ALF_NODE_TQN ON T_ALF_NODE (TYPE_QNAME_ID);
CREATE INDEX FK_ALF_NODE_TXN ON T_ALF_NODE (TRANSACTION_ID);
CREATE INDEX IDX_ALF_NODE_DEL ON T_ALF_NODE (NODE_DELETED);

-- Fill the store table
INSERT INTO T_ALF_STORE (VERSION, PROTOCOL, IDENTIFIER, ROOT_NODE_ID) (SELECT 1, STORE.PROTOCOL, STORE.IDENTIFIER, STORE.ROOT_NODE_ID FROM ALF_STORE STORE);

DROP TABLE ALF_STORE;
RENAME T_ALF_STORE TO ALF_STORE;

-- Summarize the alf_node_status table
CREATE TABLE T_SUMMARY_NSTAT ( 
    NODE_ID BIGINT NOT NULL, 
    TRANSACTION_ID BIGINT DEFAULT NULL,  
    PRIMARY KEY (NODE_ID) 
);
INSERT INTO T_SUMMARY_NSTAT (NODE_ID, TRANSACTION_ID) SELECT NODE_ID, TRANSACTION_ID FROM ALF_NODE_STATUS WHERE NODE_ID IS NOT NULL;

--FOREACH alf_node.id system.upgrade.t_alf_node.batchsize
INSERT INTO T_ALF_NODE
   (
      ID, VERSION, STORE_ID, UUID, TRANSACTION_ID, NODE_DELETED, TYPE_QNAME_ID, ACL_ID
   )
   SELECT
      N.ID, 1, S.ID, N.UUID, NSTAT.TRANSACTION_ID, 0, Q.QNAME_ID, N.ACL_ID
   FROM ALF_NODE AS N
   JOIN T_QNAMES AS Q ON (Q.QNAME = N.TYPE_QNAME)
   JOIN T_SUMMARY_NSTAT AS NSTAT ON (NSTAT.NODE_ID = N.ID)
   JOIN ALF_STORE AS S ON (S.PROTOCOL = N.PROTOCOL AND S.IDENTIFIER = N.IDENTIFIER)
   WHERE
      N.ID >= ${LOWERBOUND} AND N.ID <= ${UPPERBOUND}
;
DROP TABLE T_SUMMARY_NSTAT;

-- Hook the store up to the root node
CREATE INDEX FK_ALF_STORE_ROOT ON ALF_STORE (ROOT_NODE_ID);

-- -----------------------------
-- Populate Version Counter  --
-- -----------------------------
CREATE TABLE T_ALF_VERSION_COUNT ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY, 
    VERSION BIGINT NOT NULL, 
    STORE_ID BIGINT NOT NULL UNIQUE, 
    VERSION_COUNT INTEGER NOT NULL, 
    PRIMARY KEY (ID) 
);
CREATE INDEX FK_ALF_VC_STORE ON T_ALF_VERSION_COUNT (STORE_ID);

INSERT INTO T_ALF_VERSION_COUNT ( VERSION, STORE_ID, VERSION_COUNT ) SELECT 1, S.ID, VC.VERSION_COUNT FROM ALF_VERSION_COUNT AS VC JOIN ALF_STORE AS S ON (S.PROTOCOL = VC.PROTOCOL AND S.IDENTIFIER = VC.IDENTIFIER);

DROP TABLE ALF_VERSION_COUNT;
RENAME T_ALF_VERSION_COUNT TO ALF_VERSION_COUNT;
ALTER TABLE ALF_VERSION_COUNT ADD CONSTRAINT FK_ALF_VC_STORE FOREIGN KEY (STORE_ID) REFERENCES ALF_STORE;

-- -----------------------------
-- Populate the Child Assocs --
-- -----------------------------
--ASSIGN:aca_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_CHILD_ASSOC;

CREATE TABLE T_ALF_CHILD_ASSOC ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${aca_max_id}), 
    VERSION BIGINT NOT NULL, 
    PARENT_NODE_ID BIGINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    CHILD_NODE_NAME_CRC BIGINT NOT NULL, 
    CHILD_NODE_NAME VARCHAR(200) NOT NULL, 
    CHILD_NODE_ID BIGINT NOT NULL, 
    QNAME_NS_ID BIGINT NOT NULL, 
    QNAME_LOCALNAME VARCHAR(1020) NOT NULL, 
    IS_PRIMARY SMALLINT, 
    ASSOC_INDEX INTEGER, 
    PRIMARY KEY (ID), 
    UNIQUE (PARENT_NODE_ID, TYPE_QNAME_ID, CHILD_NODE_NAME_CRC, CHILD_NODE_NAME) 
);
CREATE INDEX FK_ALF_CASS_CNODE ON T_ALF_CHILD_ASSOC (CHILD_NODE_ID);
CREATE INDEX FK_ALF_CASS_PNODE ON T_ALF_CHILD_ASSOC (PARENT_NODE_ID);
CREATE INDEX FK_ALF_CASS_QNNS ON T_ALF_CHILD_ASSOC (QNAME_NS_ID);
CREATE INDEX FK_ALF_CASS_TQN ON T_ALF_CHILD_ASSOC (TYPE_QNAME_ID);
CREATE INDEX IDX_ALF_CASS_QNLN ON T_ALF_CHILD_ASSOC (QNAME_LOCALNAME);
CREATE INDEX IDX_ALF_CASS_PRI ON T_ALF_CHILD_ASSOC (PARENT_NODE_ID, IS_PRIMARY, CHILD_NODE_ID);

--FOREACH alf_child_assoc.id system.upgrade.t_alf_child_assoc.batchsize
INSERT INTO T_ALF_CHILD_ASSOC
   (
      ID, VERSION,
      PARENT_NODE_ID, TYPE_QNAME_ID,
      CHILD_NODE_NAME_CRC, CHILD_NODE_NAME,
      CHILD_NODE_ID, QNAME_NS_ID,
      QNAME_LOCALNAME, IS_PRIMARY, ASSOC_INDEX
   )
   SELECT
      CA.ID, 1,
      CA.PARENT_NODE_ID, TQN.QNAME_ID,
      CA.CHILD_NODE_NAME_CRC, CA.CHILD_NODE_NAME,
      CA.CHILD_NODE_ID, TQNDYN.NAMESPACE_ID,
      TQNDYN.LOCAL_NAME, CA.IS_PRIMARY, CA.ASSOC_INDEX
   FROM ALF_CHILD_ASSOC CA
   JOIN T_QNAMES_DYN TQNDYN ON (CA.QNAME = TQNDYN.QNAME)
   JOIN T_QNAMES TQN ON (CA.TYPE_QNAME = TQN.QNAME)
   WHERE
      CA.ID >= ${LOWERBOUND} AND CA.ID <= ${UPPERBOUND}
;
-- Clean up
DROP TABLE T_QNAMES_DYN;
DROP TABLE ALF_CHILD_ASSOC;
RENAME T_ALF_CHILD_ASSOC TO ALF_CHILD_ASSOC;
ALTER TABLE ALF_CHILD_ASSOC ADD CONSTRAINT FK_ALF_CASS_QNNS FOREIGN KEY (QNAME_NS_ID) REFERENCES ALF_NAMESPACE (ID);
ALTER TABLE ALF_CHILD_ASSOC ADD CONSTRAINT FK_ALF_CASS_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

-- ----------------------------
-- Populate the Node Assocs --
-- ----------------------------
--ASSIGN:ana_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from ALF_NODE_ASSOC;

CREATE TABLE T_ALF_NODE_ASSOC ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${ana_max_id}), 
    VERSION BIGINT NOT NULL, 
    SOURCE_NODE_ID BIGINT NOT NULL, 
    TARGET_NODE_ID BIGINT NOT NULL, 
    TYPE_QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (SOURCE_NODE_ID, TARGET_NODE_ID, TYPE_QNAME_ID) 
);
CREATE INDEX FK_ALF_NASS_SNODE ON T_ALF_NODE_ASSOC (SOURCE_NODE_ID);
CREATE INDEX FK_ALF_NASS_TNODE ON T_ALF_NODE_ASSOC (TARGET_NODE_ID);
CREATE INDEX FK_ALF_NASS_TQN ON T_ALF_NODE_ASSOC (TYPE_QNAME_ID);

--FOREACH alf_node_assoc.id system.upgrade.t_alf_node_assoc.batchsize
INSERT INTO T_ALF_NODE_ASSOC
   (
      ID, VERSION, SOURCE_NODE_ID, TARGET_NODE_ID, TYPE_QNAME_ID
   )
   SELECT
      NA.ID, 1, NA.SOURCE_NODE_ID, NA.TARGET_NODE_ID, TQN.QNAME_ID
   FROM ALF_NODE_ASSOC NA
   JOIN T_QNAMES TQN ON (NA.TYPE_QNAME = TQN.QNAME)
   WHERE
      NA.ID >= ${LOWERBOUND} AND NA.ID <= ${UPPERBOUND}
;

-- Clean up
DROP TABLE ALF_NODE_ASSOC;
RENAME T_ALF_NODE_ASSOC TO ALF_NODE_ASSOC;
ALTER TABLE ALF_NODE_ASSOC ADD CONSTRAINT FK_ALF_NASS_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

-- -----------------------------
-- Populate the Node Aspects --
-- -----------------------------
CREATE TABLE T_ALF_NODE_ASPECTS ( 
    NODE_ID BIGINT NOT NULL, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);
CREATE INDEX FK_ALF_NASP_N ON T_ALF_NODE_ASPECTS (NODE_ID);
CREATE INDEX FK_ALF_NASP_QN ON T_ALF_NODE_ASPECTS (QNAME_ID);

-- Note the omission of sys:referencable.  This is implicit.
--FOREACH alf_node_aspects.node_id system.upgrade.t_alf_node_aspects.batchsize
INSERT INTO T_ALF_NODE_ASPECTS
   (
      NODE_ID, QNAME_ID
   )
   SELECT
      NA.NODE_ID, TQN.QNAME_ID
   FROM
      ALF_NODE_ASPECTS NA 
      JOIN T_QNAMES TQN ON (NA.QNAME = TQN.QNAME)
   WHERE
      TQN.QNAME != '{http://www.alfresco.org/model/system/1.0}referenceable'
      AND na.node_id >= ${LOWERBOUND} AND na.node_id <= ${UPPERBOUND}
;

-- Clean up
DROP TABLE ALF_NODE_ASPECTS;
RENAME T_ALF_NODE_ASPECTS TO ALF_NODE_ASPECTS;
ALTER TABLE ALF_NODE_ASPECTS ADD CONSTRAINT fk_alf_nasp_qn FOREIGN KEY (qname_id) REFERENCES alf_qname (id);

-- ---------------------------------
-- Populate the AVM Node Aspects --
-- ---------------------------------
CREATE TABLE T_AVM_ASPECTS ( 
    NODE_ID BIGINT NOT NULL, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);

CREATE INDEX FK_AVM_NASP_N ON T_AVM_ASPECTS (NODE_ID);
CREATE INDEX FK_AVM_NASP_QN ON T_AVM_ASPECTS (QNAME_ID);

--FOREACH avm_aspects.node_id system.upgrade.t_avm_aspects.batchsize
INSERT INTO T_AVM_ASPECTS
   (
      NODE_ID, QNAME_ID
   )
   SELECT
      ASPECTS_OLD.NODE_ID, TQN.QNAME_ID
   FROM
      AVM_ASPECTS ASPECTS_OLD
      JOIN T_QNAMES TQN ON (ASPECTS_OLD.QNAME = TQN.QNAME)
   WHERE
      ASPECTS_OLD.NODE_ID >= ${LOWERBOUND} AND ASPECTS_OLD.NODE_ID <= ${UPPERBOUND}
;

--FOREACH avm_aspects_new.id system.upgrade.t_avm_aspects.batchsize
INSERT INTO T_AVM_ASPECTS
   (
      NODE_ID, QNAME_ID
   )
   SELECT
      ANEW.ID, TQN.QNAME_ID
   FROM
      AVM_ASPECTS_NEW ANEW
      JOIN T_QNAMES TQN ON (ANEW.NAME = TQN.QNAME)
      LEFT JOIN AVM_ASPECTS AOLD ON (ANEW.ID = AOLD.NODE_ID AND ANEW.NAME = AOLD.QNAME)
   WHERE
      AOLD.ID IS NULL
      AND ANEW.ID >= ${LOWERBOUND} AND ANEW.ID <= ${UPPERBOUND}
;
-- Clean up
DROP TABLE AVM_ASPECTS;
DROP TABLE AVM_ASPECTS_NEW;
RENAME T_AVM_ASPECTS TO AVM_ASPECTS;
ALTER TABLE AVM_ASPECTS ADD CONSTRAINT FK_AVM_NASP_N FOREIGN KEY (NODE_ID) REFERENCES AVM_NODES;
ALTER TABLE AVM_ASPECTS ADD CONSTRAINT FK_AVM_NASP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

-- ----------------------------------
-- Migrate Sundry Property Tables --
-- ----------------------------------

-- Create temporary mapping for property types
CREATE TABLE T_PROP_TYPES ( 
    TYPE_NAME VARCHAR(60) NOT NULL, 
    TYPE_ID INTEGER NOT NULL, 
    PRIMARY KEY (TYPE_NAME) 
);
INSERT INTO T_PROP_TYPES VALUES ('NULL', 0);
INSERT INTO T_PROP_TYPES VALUES ('BOOLEAN', 1);
INSERT INTO T_PROP_TYPES VALUES ('INTEGER', 2);
INSERT INTO T_PROP_TYPES VALUES ('LONG', 3);
INSERT INTO T_PROP_TYPES VALUES ('FLOAT', 4);
INSERT INTO T_PROP_TYPES VALUES ('DOUBLE', 5);
INSERT INTO T_PROP_TYPES VALUES ('STRING', 6);
INSERT INTO T_PROP_TYPES VALUES ('DATE', 7);
INSERT INTO T_PROP_TYPES VALUES ('DB_ATTRIBUTE', 8);
INSERT INTO T_PROP_TYPES VALUES ('SERIALIZABLE', 9);
INSERT INTO T_PROP_TYPES VALUES ('MLTEXT', 10);
INSERT INTO T_PROP_TYPES VALUES ('CONTENT', 11);
INSERT INTO T_PROP_TYPES VALUES ('NODEREF', 12);
INSERT INTO T_PROP_TYPES VALUES ('CHILD_ASSOC_REF', 13);
INSERT INTO T_PROP_TYPES VALUES ('ASSOC_REF', 14);
INSERT INTO T_PROP_TYPES VALUES ('QNAME', 15);
INSERT INTO T_PROP_TYPES VALUES ('PATH', 16);
INSERT INTO T_PROP_TYPES VALUES ('LOCALE', 17);
INSERT INTO T_PROP_TYPES VALUES ('VERSION_NUMBER', 18);

-- Modify the avm_store_properties table
--ASSIGN:asp_max_id=next_val
select case when max(id) is not null then max(id)+1 else 1 end as next_val from AVM_STORE_PROPERTIES;

CREATE TABLE T_AVM_STORE_PROPERTIES ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (start with ${asp_max_id}), 
    AVM_STORE_ID BIGINT, 
    QNAME_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    MULTI_VALUED SMALLINT NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(4096), 
    SERIALIZABLE_VALUE VARCHAR(28468) FOR BIT DATA, 
    PRIMARY KEY (ID) 
);
CREATE INDEX FK_AVM_SPROP_QNAME ON T_AVM_STORE_PROPERTIES (QNAME_ID);
CREATE INDEX FK_AVM_SPROP_STORE ON T_AVM_STORE_PROPERTIES (AVM_STORE_ID);

--FOREACH avm_store_properties.avm_store_id system.upgrade.t_avm_store_properties.batchsize
INSERT INTO T_AVM_STORE_PROPERTIES
   (
      ID, AVM_STORE_ID,
      QNAME_ID, ACTUAL_TYPE_N,
      PERSISTED_TYPE_N, MULTI_VALUED,
      BOOLEAN_VALUE, LONG_VALUE,
      FLOAT_VALUE, DOUBLE_VALUE,
      STRING_VALUE, SERIALIZABLE_VALUE
   )
   SELECT
      P.ID, P.AVM_STORE_ID,
      TQN.QNAME_ID, PTYPES_ACTUAL.TYPE_ID,
      PTYPES_PERSISTED.TYPE_ID, P.MULTI_VALUED,
      P.BOOLEAN_VALUE, P.LONG_VALUE,
      P.FLOAT_VALUE, P.DOUBLE_VALUE,
      P.STRING_VALUE, P.SERIALIZABLE_VALUE
   FROM
      AVM_STORE_PROPERTIES P
      JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME)
      JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE)
      JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE)
   WHERE
      P.AVM_STORE_ID >= ${LOWERBOUND} AND P.AVM_STORE_ID <= ${UPPERBOUND}
;

DROP TABLE AVM_STORE_PROPERTIES;
RENAME T_AVM_STORE_PROPERTIES TO AVM_STORE_PROPERTIES;
ALTER TABLE AVM_STORE_PROPERTIES ADD CONSTRAINT FK_AVM_SPROP_QNAME FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);
ALTER TABLE AVM_STORE_PROPERTIES ADD CONSTRAINT FK_AVM_SPROP_STORE FOREIGN KEY (AVM_STORE_ID) REFERENCES AVM_STORES;

-- Modify the avm_node_properties_new table
CREATE TABLE T_AVM_NODE_PROPERTIES ( 
    NODE_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    MULTI_VALUED SMALLINT NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(4096), 
    SERIALIZABLE_VALUE VARCHAR(28468) FOR BIT DATA, 
    QNAME_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID) 
);
CREATE INDEX FK_AVM_NPROP_N ON T_AVM_NODE_PROPERTIES (NODE_ID);
CREATE INDEX FK_AVM_NPROP_QN ON T_AVM_NODE_PROPERTIES (QNAME_ID);

--FOREACH avm_node_properties_new.node_id system.upgrade.t_avm_node_properties.batchsize
INSERT INTO T_AVM_NODE_PROPERTIES
   (
      NODE_ID, QNAME_ID,
      ACTUAL_TYPE_N, PERSISTED_TYPE_N,
      MULTI_VALUED, BOOLEAN_VALUE,
      LONG_VALUE, FLOAT_VALUE,
      DOUBLE_VALUE, STRING_VALUE,
      SERIALIZABLE_VALUE
   )
   SELECT
      P.NODE_ID, TQN.QNAME_ID,
      PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID,
      P.MULTI_VALUED, P.BOOLEAN_VALUE,
      P.LONG_VALUE, P.FLOAT_VALUE,
      P.DOUBLE_VALUE, P.STRING_VALUE,
      P.SERIALIZABLE_VALUE
   FROM
      AVM_NODE_PROPERTIES_NEW P 
      JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME)
      JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE)
      JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE)
   WHERE
      P.NODE_ID >= ${LOWERBOUND} AND P.NODE_ID <= ${UPPERBOUND}
;

--FOREACH avm_node_properties.node_id system.upgrade.t_avm_node_properties.batchsize
INSERT INTO T_AVM_NODE_PROPERTIES
   (
      NODE_ID, QNAME_ID,
      ACTUAL_TYPE_N, PERSISTED_TYPE_N,
      MULTI_VALUED, BOOLEAN_VALUE,
      LONG_VALUE, FLOAT_VALUE,
      DOUBLE_VALUE, STRING_VALUE,
      SERIALIZABLE_VALUE
   )
   SELECT
      P.NODE_ID, TQN.QNAME_ID,
      PTYPES_ACTUAL.TYPE_ID, PTYPES_PERSISTED.TYPE_ID,
      P.MULTI_VALUED, P.BOOLEAN_VALUE,
      P.LONG_VALUE, P.FLOAT_VALUE,
      P.DOUBLE_VALUE, P.STRING_VALUE,
      P.SERIALIZABLE_VALUE
   FROM
      AVM_NODE_PROPERTIES P 
      JOIN T_QNAMES TQN ON (P.QNAME = TQN.QNAME)
      JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = P.ACTUAL_TYPE)
      JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = P.PERSISTED_TYPE)
      LEFT OUTER JOIN T_AVM_NODE_PROPERTIES TANP ON (TQN.QNAME_ID = TANP.QNAME_ID)
   WHERE
      TANP.QNAME_ID IS NULL
      AND P.NODE_ID >= ${LOWERBOUND} AND P.NODE_ID <= ${UPPERBOUND}
;

DROP TABLE AVM_NODE_PROPERTIES;
DROP TABLE AVM_NODE_PROPERTIES_NEW;
RENAME T_AVM_NODE_PROPERTIES TO AVM_NODE_PROPERTIES;
ALTER TABLE AVM_NODE_PROPERTIES ADD CONSTRAINT FK_AVM_NPROP_N FOREIGN KEY (NODE_ID) REFERENCES AVM_NODES;
ALTER TABLE AVM_NODE_PROPERTIES ADD CONSTRAINT FK_AVM_NPROP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

-- -----------------
-- Build Locales --
-- -----------------
CREATE TABLE ALF_LOCALE ( 
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 2), 
    VERSION BIGINT NOT NULL DEFAULT 1, 
    LOCALE_STR VARCHAR(80) NOT NULL, 
    PRIMARY KEY (ID), 
    UNIQUE (LOCALE_STR) 
);
INSERT INTO ALF_LOCALE (ID, LOCALE_STR) VALUES (1, '.default');
-- Locales come from the attribute table which was used to support MLText persistence
--FOREACH alf_attributes.id system.upgrade.alf_attributes.batchsize
INSERT INTO ALF_LOCALE (LOCALE_STR)
   SELECT DISTINCT(MA.MKEY)
      FROM ALF_NODE_PROPERTIES NP
      JOIN ALF_ATTRIBUTES A1 ON (NP.ATTRIBUTE_VALUE = A1.ID)
      JOIN ALF_MAP_ATTRIBUTE_ENTRIES MA ON (MA.MAP_ID = A1.ID)
      WHERE NOT EXISTS
      (
          SELECT 1 FROM ALF_LOCALE L WHERE MA.MKEY = L.LOCALE_STR
      )
      AND A1.ID >= ${LOWERBOUND} AND A1.ID <= ${UPPERBOUND}
;

-- -------------------------------
-- Migrate ADM Property Tables --
-- -------------------------------
CREATE TABLE T_ALF_NODE_PROPERTIES ( 
    NODE_ID BIGINT NOT NULL, 
    ACTUAL_TYPE_N INTEGER NOT NULL, 
    PERSISTED_TYPE_N INTEGER NOT NULL, 
    BOOLEAN_VALUE SMALLINT, 
    LONG_VALUE BIGINT, 
    FLOAT_VALUE FLOAT, 
    DOUBLE_VALUE DOUBLE, 
    STRING_VALUE VARCHAR(4096), 
    SERIALIZABLE_VALUE VARCHAR(28468) FOR BIT DATA, 
    QNAME_ID BIGINT NOT NULL, 
    LIST_INDEX INTEGER NOT NULL, 
    LOCALE_ID BIGINT NOT NULL, 
    PRIMARY KEY (NODE_ID, QNAME_ID, LIST_INDEX, LOCALE_ID) 
);
CREATE INDEX FK_ALF_NPROP_LOC ON T_ALF_NODE_PROPERTIES (LOCALE_ID);
CREATE INDEX FK_ALF_NPROP_N ON T_ALF_NODE_PROPERTIES (NODE_ID);
CREATE INDEX FK_ALF_NPROP_QN ON T_ALF_NODE_PROPERTIES (QNAME_ID);

-- Copy values over
--FOREACH alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
INSERT INTO T_ALF_NODE_PROPERTIES
   (
      NODE_ID, QNAME_ID, LOCALE_ID,
      LIST_INDEX, ACTUAL_TYPE_N,
      PERSISTED_TYPE_N, BOOLEAN_VALUE,
      LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE,
      STRING_VALUE, SERIALIZABLE_VALUE
   )
   SELECT
      NP.NODE_ID, TQN.QNAME_ID, 1,
      -1, PTYPES_ACTUAL.TYPE_ID,
      PTYPES_PERSISTED.TYPE_ID, NP.BOOLEAN_VALUE,
      NP.LONG_VALUE, NP.FLOAT_VALUE, NP.DOUBLE_VALUE,
      NP.STRING_VALUE, NP.SERIALIZABLE_VALUE
   FROM
      ALF_NODE_PROPERTIES NP
      JOIN T_QNAMES TQN ON (NP.QNAME = TQN.QNAME)
      JOIN T_PROP_TYPES PTYPES_ACTUAL ON (PTYPES_ACTUAL.TYPE_NAME = NP.ACTUAL_TYPE)
      JOIN T_PROP_TYPES PTYPES_PERSISTED ON (PTYPES_PERSISTED.TYPE_NAME = NP.PERSISTED_TYPE)
   WHERE
      NP.ATTRIBUTE_VALUE IS NULL
      AND NP.NODE_ID >= ${LOWERBOUND} AND NP.NODE_ID <= ${UPPERBOUND}
;

--FOREACH t_alf_node.id system.upgrade.t_alf_node.batchsize
UPDATE T_ALF_NODE N SET AUDIT_CREATOR = 
(
   SELECT
      STRING_VALUE
   FROM
      T_ALF_NODE_PROPERTIES NP
      JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID)
      JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)
   WHERE
      NP.NODE_ID = N.ID AND
      NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND
      QN.LOCAL_NAME = 'creator'
)
WHERE N.ID >= ${LOWERBOUND} AND N.ID <= ${UPPERBOUND};

--FOREACH t_alf_node.id system.upgrade.t_alf_node.batchsize
UPDATE T_ALF_NODE N SET AUDIT_CREATED =
(
   SELECT
      STRING_VALUE
   FROM
      T_ALF_NODE_PROPERTIES NP
      JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID)
      JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)
   WHERE
      NP.NODE_ID = N.ID AND
      NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND
      QN.LOCAL_NAME = 'created'
)
WHERE N.ID >= ${LOWERBOUND} AND N.ID <= ${UPPERBOUND};

--FOREACH t_alf_node.id system.upgrade.t_alf_node.batchsize
UPDATE T_ALF_NODE N SET AUDIT_MODIFIER =
(
   SELECT
      STRING_VALUE
   FROM
      T_ALF_NODE_PROPERTIES NP
      JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID)
      JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)
   WHERE
      NP.NODE_ID = N.ID AND
      NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND
      QN.LOCAL_NAME = 'modifier'
)
WHERE N.ID >= ${LOWERBOUND} AND N.ID <= ${UPPERBOUND};

--FOREACH t_alf_node.id system.upgrade.t_alf_node.batchsize
UPDATE T_ALF_NODE N SET AUDIT_MODIFIED =
(
   SELECT
	  STRING_VALUE
   FROM
      T_ALF_NODE_PROPERTIES NP
      JOIN ALF_QNAME QN ON (NP.QNAME_ID = QN.ID)
      JOIN ALF_NAMESPACE NS ON (QN.NS_ID = NS.ID)
   WHERE
      NP.NODE_ID = N.ID AND
      NS.URI = 'FILLER-http://www.alfresco.org/model/content/1.0' AND
      QN.LOCAL_NAME = 'modified'
)
WHERE N.ID >= ${LOWERBOUND} AND N.ID <= ${UPPERBOUND};

--FOREACH t_alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
DELETE
   FROM T_ALF_NODE_PROPERTIES
   WHERE T_ALF_NODE_PROPERTIES.QNAME_ID IN 
                  (
                      SELECT ID FROM ALF_QNAME 
                      WHERE
                      ALF_QNAME.NS_ID = 
                      (
                         SELECT ID FROM ALF_NAMESPACE WHERE URI = 'FILLER-http://www.alfresco.org/model/content/1.0'
                      )
                      AND ALF_QNAME.LOCAL_NAME IN ('creator', 'created', 'modifier', 'modified')
                  )
   AND T_ALF_NODE_PROPERTIES.NODE_ID >= ${LOWERBOUND} AND T_ALF_NODE_PROPERTIES.NODE_ID <= ${UPPERBOUND}
;

--FOREACH alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
INSERT INTO T_ALF_NODE_PROPERTIES
   (
      NODE_ID, QNAME_ID, LOCALE_ID, LIST_INDEX,
      ACTUAL_TYPE_N, PERSISTED_TYPE_N,
	  BOOLEAN_VALUE, LONG_VALUE, FLOAT_VALUE, DOUBLE_VALUE,
      STRING_VALUE, SERIALIZABLE_VALUE
   )
   SELECT
      NP.NODE_ID, TQN.QNAME_ID, LOC.ID, -1,
      -1, 0,
      0, 0, 0, 0,
      A2.STRING_VALUE, A2.SERIALIZABLE_VALUE
   FROM
      ALF_NODE_PROPERTIES NP
      JOIN T_QNAMES TQN ON (NP.QNAME = TQN.QNAME)
      JOIN ALF_ATTRIBUTES A1 ON (NP.ATTRIBUTE_VALUE = A1.ID)
      JOIN ALF_MAP_ATTRIBUTE_ENTRIES MA ON (MA.MAP_ID = A1.ID)
      JOIN ALF_LOCALE LOC ON (MA.MKEY = LOC.LOCALE_STR)
      JOIN ALF_ATTRIBUTES A2 ON (MA.ATTRIBUTE_ID = A2.ID)
   WHERE
      NP.NODE_ID >= ${LOWERBOUND} AND NP.NODE_ID <= ${UPPERBOUND}
;  -- (OPTIONAL)
--FOREACH t_alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
UPDATE T_ALF_NODE_PROPERTIES
   SET ACTUAL_TYPE_N = 6, PERSISTED_TYPE_N = 6, SERIALIZABLE_VALUE = NULL
   WHERE ACTUAL_TYPE_N = -1 AND STRING_VALUE IS NOT NULL
   AND T_ALF_NODE_PROPERTIES.NODE_ID >= ${LOWERBOUND} AND T_ALF_NODE_PROPERTIES.NODE_ID <= ${UPPERBOUND};
--FOREACH t_alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
UPDATE T_ALF_NODE_PROPERTIES
   SET ACTUAL_TYPE_N = 9, PERSISTED_TYPE_N = 9
   WHERE ACTUAL_TYPE_N = -1 AND SERIALIZABLE_VALUE IS NOT NULL
   AND T_ALF_NODE_PROPERTIES.NODE_ID >= ${LOWERBOUND} AND T_ALF_NODE_PROPERTIES.NODE_ID <= ${UPPERBOUND};
--FOREACH t_alf_node_properties.node_id system.upgrade.t_alf_node_properties.batchsize
DELETE FROM T_ALF_NODE_PROPERTIES
   WHERE ACTUAL_TYPE_N = -1
   AND T_ALF_NODE_PROPERTIES.NODE_ID >= ${LOWERBOUND} AND T_ALF_NODE_PROPERTIES.NODE_ID <= ${UPPERBOUND}
;
DROP TABLE ALF_NODE_PROPERTIES;
RENAME T_ALF_NODE_PROPERTIES TO ALF_NODE_PROPERTIES;
ALTER TABLE ALF_NODE_PROPERTIES ADD CONSTRAINT FK_ALF_NPROP_LOC FOREIGN KEY (LOCALE_ID) REFERENCES ALF_LOCALE (ID);
ALTER TABLE ALF_NODE_PROPERTIES ADD CONSTRAINT FK_ALF_NPROP_QN FOREIGN KEY (QNAME_ID) REFERENCES ALF_QNAME (ID);

CREATE TABLE T_DEL_ATTRIBUTES
(
   ID BIGINT NOT NULL,
   PRIMARY KEY (ID)
);

--FOREACH alf_attributes.id system.upgrade.t_del_attributes.batchsize
INSERT INTO T_DEL_ATTRIBUTES 
   SELECT ID FROM ALF_ATTRIBUTES WHERE TYPE = 'M'
   AND ALF_ATTRIBUTES.ID >= ${LOWERBOUND} AND ALF_ATTRIBUTES.ID <= ${UPPERBOUND}
;

--FOREACH t_del_attributes.id system.upgrade.t_del_attributes.batchsize
DELETE
   FROM T_DEL_ATTRIBUTES
   WHERE EXISTS
   (
      SELECT 1 FROM ALF_MAP_ATTRIBUTE_ENTRIES AS MA WHERE MA.ATTRIBUTE_ID = T_DEL_ATTRIBUTES.ID
   )
   AND T_DEL_ATTRIBUTES.ID >= ${LOWERBOUND} AND T_DEL_ATTRIBUTES.ID <= ${UPPERBOUND}
;

--FOREACH t_del_attributes.id system.upgrade.t_del_attributes.batchsize
DELETE
   FROM T_DEL_ATTRIBUTES
   WHERE EXISTS
   (
      SELECT 1 FROM ALF_LIST_ATTRIBUTE_ENTRIES AS LA WHERE LA.ATTRIBUTE_ID = T_DEL_ATTRIBUTES.ID
   )
   AND T_DEL_ATTRIBUTES.ID >= ${LOWERBOUND} AND T_DEL_ATTRIBUTES.ID <= ${UPPERBOUND}
;

--FOREACH t_del_attributes.id system.upgrade.t_del_attributes.batchsize
DELETE
   FROM T_DEL_ATTRIBUTES
   WHERE EXISTS
   (
      SELECT 1 FROM ALF_GLOBAL_ATTRIBUTES AS GA WHERE GA.ATTRIBUTE = T_DEL_ATTRIBUTES.ID
   )
   AND T_DEL_ATTRIBUTES.ID >= ${LOWERBOUND} AND T_DEL_ATTRIBUTES.ID <= ${UPPERBOUND}
;

--FOREACH t_del_attributes.id system.upgrade.t_del_attributes.batchsize
INSERT INTO T_DEL_ATTRIBUTES
   SELECT A.ID FROM T_DEL_ATTRIBUTES AS T
   JOIN ALF_MAP_ATTRIBUTE_ENTRIES AS MA ON (MA.MAP_ID = T.ID)
   JOIN ALF_ATTRIBUTES AS A ON (MA.ATTRIBUTE_ID = A.ID)
   WHERE T.ID >= ${LOWERBOUND} AND T.ID <= ${UPPERBOUND}
;

--FOREACH alf_map_attribute_entries.map_id system.upgrade.alf_map_attribute_entries.batchsize
DELETE
   FROM ALF_MAP_ATTRIBUTE_ENTRIES
   WHERE EXISTS
   (
      SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE ALF_MAP_ATTRIBUTE_ENTRIES.MAP_ID = T.ID
   )
   AND ALF_MAP_ATTRIBUTE_ENTRIES.MAP_ID >= ${LOWERBOUND} AND ALF_MAP_ATTRIBUTE_ENTRIES.MAP_ID <= ${UPPERBOUND}
;

--FOREACH alf_list_attribute_entries.list_id system.upgrade.alf_list_attribute_entries.batchsize
DELETE
   FROM ALF_LIST_ATTRIBUTE_ENTRIES
   WHERE EXISTS
   (
      SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE ALF_LIST_ATTRIBUTE_ENTRIES.LIST_ID = T.ID
   )
   AND ALF_LIST_ATTRIBUTE_ENTRIES.LIST_ID >= ${LOWERBOUND} AND ALF_LIST_ATTRIBUTE_ENTRIES.LIST_ID <= ${UPPERBOUND}
;

--FOREACH alf_attributes.id system.upgrade.alf_attributes.batchsize
DELETE
   FROM ALF_ATTRIBUTES
   WHERE EXISTS
   (
      SELECT 1 FROM T_DEL_ATTRIBUTES AS T WHERE ALF_ATTRIBUTES.ID = T.ID
   )
   AND ALF_ATTRIBUTES.ID >= ${LOWERBOUND} AND ALF_ATTRIBUTES.ID <= ${UPPERBOUND}
;
DROP TABLE T_DEL_ATTRIBUTES;

-- ---------------------------------------------------
-- Remove the FILLER- values from the namespace uri --
-- ---------------------------------------------------
UPDATE ALF_NAMESPACE SET URI = '.empty' WHERE URI = 'FILLER-';
UPDATE ALF_NAMESPACE SET URI = SUBSTR(URI, 8) WHERE URI LIKE 'FILLER-%';

-- ------------------
-- Final clean up --
-- ------------------
DROP TABLE T_QNAMES;
DROP TABLE T_PROP_TYPES;
DROP TABLE ALF_NODE_STATUS;
DROP TABLE ALF_NODE;
RENAME T_ALF_NODE TO ALF_NODE;


-- -------------------------------------
-- Modify index and constraint names --
-- -------------------------------------
--alf_attributes
DROP INDEX fk_attributes_n_acl;  -- (optional)
ALTER TABLE alf_attributes DROP FOREIGN KEY fk_attributes_n_acl;  -- (optional)
DROP INDEX fk_attr_n_acl;  -- (optional)
ALTER TABLE alf_attributes DROP FOREIGN KEY fk_attr_n_acl;  -- (optional)
CREATE INDEX fk_alf_attr_acl ON alf_attributes (acl_id);
ALTER TABLE ALF_ATTRIBUTES ADD CONSTRAINT FK_ALF_ATTR_ACL FOREIGN KEY (ACL_ID) REFERENCES ALF_ACCESS_CONTROL_LIST;

--alf_global_attributes
ALTER TABLE alf_global_attributes DROP FOREIGN KEY FK64D0B9CF69B9F16A; -- (optional)
DROP INDEX FK64D0B9CF69B9F16A; -- (optional)
create index fk_alf_gatt_att on alf_global_attributes (attribute);
alter table alf_global_attributes add constraint fk_alf_gatt_att foreign key (attribute) references alf_attributes;

--alf_list_attribute_entries
ALTER TABLE alf_list_attribute_entries DROP FOREIGN KEY FKC7D52FB02C5AB86C; -- (optional)
ALTER TABLE alf_list_attribute_entries DROP FOREIGN KEY FKC7D52FB0ACD8822C; -- (optional)
DROP INDEX FKC7D52FB02C5AB86C; -- (optional)
DROP INDEX FKC7D52FB0ACD8822C; -- (optional)
create index fk_alf_lent_latt on alf_list_attribute_entries (list_id);
alter table alf_list_attribute_entries add constraint fk_alf_lent_latt foreign key (list_id) references alf_attributes;
create index fk_alf_lent_att on alf_list_attribute_entries (attribute_id);
alter table alf_list_attribute_entries add constraint fk_alf_lent_att foreign key (attribute_id) references alf_attributes;

--alf_map_attribute_entries
DROP INDEX FK335CAE26AEAC208C; -- (optional)
DROP INDEX FK335CAE262C5AB86C; -- (optional)
ALTER TABLE alf_map_attribute_entries DROP FOREIGN KEY FK335CAE262C5AB86C; -- (optional)
ALTER TABLE alf_map_attribute_entries DROP FOREIGN KEY FK335CAE26AEAC208C; -- (optional)
create index fk_alf_matt_att on alf_map_attribute_entries (attribute_id);
alter table alf_map_attribute_entries add constraint fk_alf_matt_att foreign key (attribute_id) references alf_attributes;
create index fk_alf_matt_matt on alf_map_attribute_entries (map_id);
alter table alf_map_attribute_entries add constraint fk_alf_matt_matt foreign key (map_id) references alf_attributes;

--alf_transaction
DROP INDEX idx_commit_time_ms; -- (optional)
DROP INDEX FKB8761A3A9AE340B7;
ALTER TABLE alf_transaction DROP FOREIGN KEY FKB8761A3A9AE340B7; -- (optional)
create index fk_alf_txn_svr on alf_transaction (server_id);
alter table alf_transaction add constraint fk_alf_txn_svr foreign key (server_id) references alf_server;
create index idx_alf_txn_ctms on alf_transaction (commit_time_ms);

--FOREACH alf_transaction.id system.upgrade.alf_transaction.batchsize
UPDATE ALF_TRANSACTION SET COMMIT_TIME_MS = ID WHERE COMMIT_TIME_MS IS NULL
AND ALF_TRANSACTION.ID >= ${LOWERBOUND} AND ALF_TRANSACTION.ID <= ${UPPERBOUND};

--avm_child_entries
DROP INDEX fk_avm_ce_child; -- (optional)
alter table avm_child_entries DROP FOREIGN KEY fk_avm_ce_child; -- (optional)
DROP INDEX fk_avm_ce_parent; -- (optional)
alter table avm_child_entries DROP FOREIGN KEY fk_avm_ce_parent; -- (optional)
create index fk_avm_ce_child on avm_child_entries (child_id); 
alter table avm_child_entries ADD CONSTRAINT fk_avm_ce_child FOREIGN KEY (child_id) REFERENCES avm_nodes (id);
create index fk_avm_ce_parent on avm_child_entries (parent_id);
alter table avm_child_entries ADD CONSTRAINT fk_avm_ce_parent FOREIGN KEY (parent_id) REFERENCES avm_nodes (id);

--avm_history_links
DROP INDEX fk_avm_hl_desc; -- (optional)
DROP INDEX fk_avm_hl_ancestor; -- (optional)
DROP INDEX idx_avm_hl_revpk; -- (optional)
alter table avm_history_links DROP FOREIGN KEY fk_avm_hl_desc; -- (optional)
alter table avm_history_links DROP FOREIGN KEY fk_avm_hl_ancestor; -- (optional)
create index fk_avm_hl_desc on avm_history_links (descendent);
alter table avm_history_links ADD CONSTRAINT fk_avm_hl_desc FOREIGN KEY (descendent) REFERENCES avm_nodes (id);
create index fk_avm_hl_ancestor on avm_history_links (ancestor);
alter table avm_history_links ADD CONSTRAINT fk_avm_hl_ancestor FOREIGN KEY (ancestor) REFERENCES avm_nodes (id);
create index idx_avm_hl_revpk on avm_history_links (descendent, ancestor);

--avm_merge_links
DROP INDEX fk_avm_ml_to; -- (optional)
DROP INDEX fk_avm_ml_from; -- (optional)
ALTER TABLE avm_merge_links DROP FOREIGN KEY fk_avm_ml_to; -- (optional)
ALTER TABLE avm_merge_links DROP FOREIGN KEY fk_avm_ml_from; -- (optional)
create index fk_avm_ml_to on avm_merge_links (mto);
ALTER TABLE avm_merge_links ADD CONSTRAINT fk_avm_ml_to FOREIGN KEY (mto) REFERENCES avm_nodes (id);
create index fk_avm_ml_from on avm_merge_links (mfrom);
ALTER TABLE avm_merge_links ADD CONSTRAINT fk_avm_ml_from FOREIGN KEY (mfrom) REFERENCES avm_nodes (id);

--avm_nodes
DROP INDEX fk_avm_n_acl; -- (optional)
DROP INDEX fk_avm_n_store; -- (optional)
DROP INDEX idx_avm_n_pi; -- (optional)
ALTER TABLE avm_nodes DROP FOREIGN KEY fk_avm_n_acl; -- (optional)
ALTER TABLE avm_nodes DROP FOREIGN KEY fk_avm_n_store; -- (optional)
create index fk_avm_n_acl on avm_nodes (acl_id); 
ALTER TABLE avm_nodes ADD CONSTRAINT fk_avm_n_acl FOREIGN KEY (acl_id) REFERENCES alf_access_control_list (id);
create index fk_avm_n_store on avm_nodes (store_new_id);
ALTER TABLE avm_nodes ADD CONSTRAINT fk_avm_n_store FOREIGN KEY (store_new_id) REFERENCES avm_stores (id);
create index idx_avm_n_pi on avm_nodes (primary_indirection);

--avm_stores
DROP INDEX fk_avm_s_root; -- (optional)
ALTER TABLE avm_stores DROP FOREIGN KEY fk_avm_s_root; -- (optional)
create index fk_avm_s_acl on avm_stores (acl_id);
ALTER TABLE avm_stores ADD CONSTRAINT fk_avm_s_acl FOREIGN KEY (acl_id) REFERENCES alf_access_control_list (id);
create index fk_avm_s_root on avm_stores (current_root_id);
ALTER TABLE avm_stores ADD CONSTRAINT fk_avm_s_root FOREIGN KEY (current_root_id) REFERENCES avm_nodes (id);

--avm_version_layered_node_entry
DROP INDEX FK182E672DEB9D70C; -- (optional)
ALTER TABLE avm_version_layered_node_entry DROP FOREIGN KEY FK182E672DEB9D70C; -- (optional)
create index fk_avm_vlne_vr on avm_version_layered_node_entry (version_root_id);
alter table avm_version_layered_node_entry add constraint fk_avm_vlne_vr foreign key (version_root_id) references avm_version_roots;

--avm_version_roots
DROP INDEX idx_avm_vr_version; -- (optional)
DROP INDEX idx_avm_vr_revuq; -- (optional)
DROP INDEX fk_avm_vr_root; -- (optional)
DROP INDEX fk_avm_vr_store; -- (optional)
ALTER TABLE avm_version_roots DROP FOREIGN KEY fk_avm_vr_root; -- (optional)
ALTER TABLE avm_version_roots DROP FOREIGN KEY fk_avm_vr_store; -- (optional)
create index fk_avm_vr_store on avm_version_roots (avm_store_id);
ALTER TABLE avm_version_roots ADD CONSTRAINT fk_avm_vr_store FOREIGN KEY (avm_store_id) REFERENCES avm_stores (id);
create index fk_avm_vr_root on avm_version_roots (root_id);
ALTER TABLE avm_version_roots ADD CONSTRAINT fk_avm_vr_root FOREIGN KEY (root_id) REFERENCES avm_nodes (id);
create index idx_avm_vr_version on avm_version_roots (version_id);
create index idx_avm_vr_revuq on avm_version_roots (avm_store_id, version_id);

--ALF_NODE
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_TXN FOREIGN KEY (TRANSACTION_ID) REFERENCES ALF_TRANSACTION;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_ACL FOREIGN KEY (ACL_ID) REFERENCES ALF_ACCESS_CONTROL_LIST;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_STORE FOREIGN KEY (STORE_ID) REFERENCES ALF_STORE;
ALTER TABLE ALF_NODE ADD CONSTRAINT FK_ALF_NODE_TQN FOREIGN KEY (TYPE_QNAME_ID) REFERENCES ALF_QNAME (ID);

alter table alf_child_assoc add constraint fk_alf_cass_cnode foreign key (child_node_id) references alf_node;
alter table alf_child_assoc add constraint fk_alf_cass_pnode foreign key (parent_node_id) references alf_node;
alter table alf_node_aspects add constraint fk_alf_nasp_n foreign key (node_id) references alf_node;
alter table alf_node_assoc add constraint fk_alf_nass_snode foreign key (source_node_id) references alf_node;
alter table alf_node_assoc add constraint fk_alf_nass_tnode foreign key (target_node_id) references alf_node;
alter table alf_node_properties add constraint fk_alf_nprop_n foreign key (node_id) references alf_node;
alter table alf_store add constraint fk_alf_store_root foreign key (root_node_id) references alf_node;
--
-- Record script finish
--
DELETE FROM alf_applied_patch WHERE id = 'patch.db-V2.2-Upgrade-From-2.1';
INSERT INTO alf_applied_patch
  (id, description, fixes_from_schema, fixes_to_schema, applied_to_schema, target_schema, applied_on_date, applied_to_server, was_executed, succeeded, report)
  VALUES
  (
    'patch.db-V2.2-Upgrade-From-2.1', 'Manually executed script upgrade V2.2: Upgrade from 2.1',
    0, 85, -1, 91, null, 'UNKNOWN', ${TRUE}, ${TRUE}, 'Script completed'
  );